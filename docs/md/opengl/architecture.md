# OpenGL 架构

这是网上能够随处找到的一个 OpenGL 架构图.

![OpenGL Architecture](https://web.cs.wpi.edu/~matt/courses/cs563/talks/OpenGL_Presentation/OpenGL_Pipeline.JPG)

配图来自于 [Overview of OpenGL](https://web.cs.wpi.edu/~matt/courses/cs563/talks/OpenGL_Presentation/OpenGL_Presentation.html).

不用管上面的英语, 简单来说, OpenGL 是一个异步架构 (可以使用同步的方式运行, 但是效率会大大降低), 可以大致分成 CPU 和 GPU 端 (有时候也被成为客户端和服务端), CPU 端发出命令, GPU 端负责执行它们.


### CPU 端驱动

CPU 端驱动是一组编程接口, 例如 GLUT, GLFW, 或者 WebGL API, 它们的 API 其实非常接近, 名称和常量命名也几乎完全一致, 熟悉一个也就熟悉了其他所有.

CPU 端驱动会做的事情包括: 准备 GPU 端渲染所需的所有资源, 配置绘制环境和变量, 创建绘制程序以及调用绘制命令, 处理和 GPU 端的信息的同步.



### GPU 端管线

GPU 端通过多个着色程序来回在画布上 (或者一个帧缓存上) 绘制像素.

首先将顶点数据中的每个顶点并行运行顶点着色, 确定顶点的最终坐标. 顶点着色相当于画轮廓线, 只有轮廓线内部的区域会被填色.

之后对于最终顶点坐标组成的区域进行栅格化, 再并行地逐像素调用片元着色. 片元着色相当于在轮廓线内填颜色.

显然大多数情况下顶点并不多, 但是片元总是会很多. 所以大多数情况下的 GPU 端的性能瓶颈是片元着色.

<iframe src="https://webglfundamentals.org/webgl/lessons/resources/fragment-shader-anim.html" style="width: 402px; height: 302px; margin-top: 20px"></iframe>

配图来自于 [WebGL Fundamentals](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html)



### 栅格化过程

上面的配图可能会让你觉得着色是一个个像素完成的, 不过实际上它一般是一行行完成的, 或者每两行完成的. 可以称其为行扫描线栅格化.

我们在直觉上可能会感觉如果我们有 100 万个着色单元, 那么 1080p 的片元着色似乎可以瞬间完成. 这个问题得分情况:

如果每个片元只是简单的数学计算, 不用访问纹理数据等公共数据, 也不用和其他片元保持同步, 那么的确如此.

不过在绝大多数的情况下, 片元会读取纹理数据 (也包括公共变量), 显然我们没办法把纹理数据全部拷贝到每个着色单元最近的缓存 (因为最近的缓存非常小, 但是速度也非常快), 所以 100 万个着色单元会有 100 万次对于次级缓存的读请求, 你想象一下这有多么可怕...

实际的 GPU 单元会有几百个到几千个, 会刚好和显示器分辨率的宽或者其 1/2, 1/4, 1/8 接近.

实际的栅格化过程按照行来进行, 并且可以按照上两行的某些结果来预测下一行的结果, 因此可以用于猜测下一行每个单元会访问的纹理数据的坐标, 从而在下一行的着色开始之前就将其可能访问的小块纹理数据加载到最近的缓存中.

这类预测命中率非常高, 而且对于绘制效率影响重大. 不过另一方面, 如果你的着色程序随机访问 (或者以局部非线性的方式访问) 纹理数据的某个位置, 你会发现效率非常差.



### 图形与图像

我们常说 **计算机图形学** 和 **计算机图像学**, 前者偏向于处理图形, 即物体对象和其运动; 后者偏向于处理物体表面, 即像素的颜色值.

放在 OpenGL 中, 我们可以简单认为顶点着色处理图形, 而片元着色处理图像.

不过其实片元着色非常强大, 通过合适的建模和滤波, 可以完成许多通过顶点着色都无法完成的效果, 不信的话可以看下这个: [Happy Jumping - ShaderToy](https://www.shadertoy.com/view/3lsSzf).
