# 性能 (Performance)

OpenGL 的性能包含了多个方面, 一般而言, 我们如果了解了 OpenGL 的运行机制的话, 可很快断言某些操作是否可能产生性能问题, 以及出现性能问题时具体出现在哪个环节.



### 顶点着色

顶点着色一般而言不会产生性能问题, 除非你真的有几百万的顶点数据需要绘制, 此时应该使用实例绘制.



### 片元着色

片元着色是开销最大的, 对于片元着色也难以具体优化, 一般只能通过减小分辨率, 减少要绘制的对象或者减少绘制步骤, 设置合适的坐标裁剪方式来减少片元着色次数.



### 状态和变量设置

在我们的绘制过程中, 可能需要频繁地设置上下文状态, 例如设置融混方式, 当前顶点数据与纹理单元等等.

这些设置会经过命令队列一次或者分批同步到 GPU 端, 一般而言这些设置只是一些状态的切换, 效率非常高.

不过仍然建议不要做不产生实际作用的状态设置, 此部分可以在应用端设置状态缓存, 如果设置状态时不用切换, 则不必同步状态到 GPU.

着色器变量的设置同理.



### 绘制步骤和绘制对象数目

减少绘制步骤意味着更少次数地从 CPU 端同步命令到 GPU 端, 对于绘制效率有着巨大的提升, 所以使用实例绘制时绘制很高.

减少绘制对象数目意味着更少的片元着色, 同时 GPU 端在绘制多个对象时, 会比对以确定不同面的顶点是否一致, 即不同面的边是否重叠等, 减少对象数目也意味着此部分的压力降低.



### 纹理的上传与 CPU 和 GPU 之间的带宽

CPU 和 GPU 之间的带宽是 CPU 和 GPU 端的数据传输的速度, 一般只有纹理数据的传输会带来带宽压力.

一般 CPU 和 GPU 之间的带宽能够至少满足其所支持的最高分辨率下的满帧率的数据传输, 例如支持 4K 60 帧分辨率时, 其带宽至少 4K \* 2K \* 4(RGBA) \* 60 = 2GB/s. (一般 CPU 和 GPU 之间带宽受制于 CPU 和 GPU 频率, 以及他们之间连接的 PCIE 总线的位宽). 较高端设备的 CPU 和 GPU 之间带宽能够至少达到 16G/s, 而 GPU 内部的带宽可以高达数百 G/s.

实测一般向 GPU 实时传输 1080p 纹理所需的带宽约为 500M/s 左右, 不会产生问题, 不过需要注意的是解图片或者视频会占用 CPU 时间.



### 一般不会产生性能问题, 但是可以优化的方面

采样方式: 前面说过采样时读取的像素数目越高, 效率越低, 但是两者并不成线性比例. 不过在效果差不多的时候使用读取像素数目更少的采样方式会更佳.

MSAA: MSAA 使用覆盖模板抗锯齿, 1080p 下 MSAA x8 会初始化一个 1920 \* 1080 \* 8^2 / 8(比特转字节) = 16MB 的覆盖模板缓冲, 同时在顶点栅格化过程中会产生 64 倍的写入. 但是其相比 x2 的超采样, 在带来更佳效果的同时, 性能损失却并不多. 性价比非常高, 抗锯齿首选. 如果没有必要进行抗锯齿, 例如没有物体倾斜或在运动, 则没有必要开启.

Alpha 通道: Alpha 通道会带来 1/3 的额外的颜色缓存消耗, 和 1/3 的写入. 但是由于它对于颜色混合直观重要, 所以只要你绘制的某个对象为半透明, 需要抗锯齿, 或者融合, 都必须开启 Alpha 通道. 或者你也可以始终开启它, 除非需要绘制的内容非常简单, 像素风, 或者需要极端地优化性能时再考虑将其关闭.
