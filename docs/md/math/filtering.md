# 滤波

滤波这个名词来自于数字信号处理, 一般用来表示滤除低频率或者高频率, 或者指定频率范围的数字波. 我在 `<<OpenGL 编程指南>>` 的反走样一章中第一次见到这个词.

滤波和平滑两个词是有区别, 我看到过一些情况下两个词被混淆. 其实平滑指的应该是边缘的过渡处理, 可以使用滤波也可以使用其他方式实现 (例如 MSAA), 而滤波是通用的信号的过滤处理, 可以实现平滑, 也可以实现其他的效果.



### 还是那个简单的转场

在上一节 [向量模型](#math/vector-modeling) 中, 我们那个最简单的 Push 转场, 在实现之后会发现边缘有跳动, 其实就是逐渐递进的现象. 它产生的原因非常简单, 就是我们使用逻辑判断一个像素属于新图还是旧图, 并且只会是新图或者旧图, 所以这个转场便会一像素一像素地推进:

![](md/images/2019-11-25_17-22-10.jpg)

因为前进速度和屏幕刷新的速度不同步, 所以可能前两帧我们看到它完全没动, 但是下一帧却突然移动了 1px, 这就是为何它会产生跳动.

这其实并不要命, 因为 1px 递进的变化即使被留意到, 也影响不大, 因为它只是看起来不流畅, 但是并不扎眼.

真正要命的是另一类问题: 晃动, 接缝. 这些都是我实际碰到过的, 但是我在这里不做过多的叙述, 因为你也一定会碰到这些问题, 那个时候刚好可以锻炼自己的滤波处理技巧.



### 滤波函数

常用的滤波函数有 `step`, `smoothstep`.

![](md/images/2019-11-25_17-22-37.jpg)

`step` 在边缘会产生断层, 而 `smoothstep` 会在边缘的某个范围进行过渡.

通过组合这些滤波函数, 可以也可以自定义更多的滤波函数, 例如一个两端平滑下降的滤波函数:

![](md/images/2019-11-25_17-22-49.jpg)



### 边缘平滑和过渡

一般只需要在边缘的 1px 范围做平滑, 效果就会很好.

我们也可以增大这个范围, 让边缘逐渐过渡到另一个图像, 而形成边缘的一个渐变过渡效果. 这里可以做的文章非常多, 有许多的看起来匪夷所思的东西, 起关键作用的可能就是一个简单的滤波函数.

不过在此我们只讨论这个 1px 的平滑.



### 平滑

这是我们的一个理想的滤波函数, 它会在 1px 的范围进行平滑.

我们需要首先确定我们针对哪个变量进行滤波, 也就是, 这个图像的 x 轴到底是谁.

![](md/images/2019-11-25_17-22-55.jpg)


例如, 在上面的 Push 转场中, x 轴就表示当前像素投影到运动方向后的位置.

之后, 我们需要确定我们在哪个范围进行平滑, 即平滑范围的上下界. 这个范围一般是以区间中值和一个区间长度表示出来.

例如, 在上面的 Push 转场中, 区间中值就是那条推进线在运动方向向量的投影位置. 而区间长度很明显就是 1px. 不过注意这里的区间中值和区间长度是一个坐标系的, 也就是如果我们用于进行滤波的变量不是基于 px 单位的, 那么需要针对调整区间长度刚好对应像素坐标系内 1px 的变化.

注意实际应用中, 我们希望的平滑范围可能不总是以某个值为中心的, 也可能以某个值为左值或者右值, 这需要我们根据具体情况来判断.



### 梯度

那么我们假设在像素坐标系内变化了 1px, 那么我们怎么知道用来滤波的变量的对应的变化范围, 从而确定滤波的平滑区间呢?

答案是梯度.

原始的梯度定义是一个矢量, 它的意义就是导数或者偏导数变化速度最快那个方向, 也可以简单理解为下坡或者上坡最快, 或者距离最短的那个方向.

我们可以在这里使用一个简化的概念: 只表示矢量的倾斜程度, 然后用梯度矢量表示原先的矢量.

我觉得梯度这个名词很好, 因为你一看到它就知道它的意思是它代表了一个面的倾斜程度, 然后你坐上去还可以滑下来, 梯度越大, 你滑下去越快, 爬上来也越难.

如果像素坐标系内变化了 1px (准确来说是梯度方向上变化了 1px), 那么我们的滤波变量的变化量在像素坐标系内会刚好是这个梯度 (注意它的单位是 px, 可能需要转为变量所在坐标系). 这个不太好理解, 我们举个例子:

![](md/images/2019-11-25_17-23-03.jpg)

我们把一张纸竖起来和地面成 $60^\circ$ 角, 这时候的梯度为 $\tan 60^\circ = \sqrt{3}$, 在 x 方向每变化 1px 时, y 方向会变化 1.73px.

即使我们的滤波变量不放在像素坐标系内, 它的变化量仍然对应着像素坐标系的 1px. 这个比较容易理解.

所以我们最终的平滑范围即为变量的梯度.



### GLSL 编程中的梯度

GLSL 为我们提供了三个 API: `dFdx`, `dFdy`, `fwidth`.

`dFdx`, `dFdy` 分别代表了在 X 和 Y 方向, 片元位置变化 1px 时的指定变量的变化量 (偏导数), 他们的平方平均数即为梯度, 即 $\textit{fwidth} = |dFdx| + |dFdy|$, 可以近似作为梯度使用.

所以我们可以使用 `fwidth(variable)` 来表示 `variable` 的平滑区间长度, 来刚好在 1px 范围内平滑.



### 建模的选择和梯度

模型的选择对于滤波的复杂度有着非常直接的影响, 一般而言, 如果我们能在梯度方向上进行建模, 例如在 Push 转场的运动方向上, 或者渲染圆形使用的极坐标半径上, 那么我们可以将滤波处理也跟随者模型简化为 1 维的形式.


### 何时使用梯度函数

很明显有时候需要使用梯度函数, 而有时候似乎又不需要, 怎么辨别呢?

首先总是使用梯度函数的话, 结果是不会错的, 但是使用梯度函数会对渲染性能产生一定的影响: 片元调度程序在遇到梯度函数时, 会执行一个同步过程, 确保右侧和下方的片元也运行到同样的位置, 然后根据梯度函数的参数推断出其在 X 和 Y 方向的偏导数.

一般而言, 我们看变量在梯度方向 (变化最快的那个方向) 的坡度是否为一个定值, 如果是, 则只需要使用这个值即可.