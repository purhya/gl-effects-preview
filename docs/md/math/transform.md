# 变换的数学原理

在过去的很多年里, 我查询过非常多关于矩阵变换的文章, 但是未能得到一个关于变换的准确的数学模型. 尤其是很难理解为何基于固定坐标系的变换和基于元素自身坐标系的变换, 两者的矩阵相乘的顺序是相反的.

在我重温了线性代数之后, 我才发现相应的基础性原理都包含在里面, 所以在此推导出关于变换的数学模型, 并且借其在编程中处理变换和变换矩阵.

很抱歉这里没有配图, 因为这篇文章的目的是通过数学语言来描述矩阵变换的原理.



### 在单一的 Viewport 坐标系内变换对象

设点 $P$ 分别经过了 $M_1$ 和 $M_2$ 两个变换, 则变换产生的新的点 $P' = M_2 × M_1 × P$, $P$ 和 $Mi$ 均位于 Viewport 坐标系内.

最终变换矩阵 $M_{final} = M_2 × M_1$, 即变换矩阵逆向相乘.



### 以另一坐标系变换对象

设 $V_1$ 坐标系对应的基底为 $B_1$, 它是由一组列向量组成, 代表了矩阵的每个轴方向的单位向量.

设另一坐标系为 $V_2$, 对应的基底为 $B_2$. 设 $B_1$ 到 $B_2$ 的过渡矩阵 $C$ 满足 $B_2 = B_1C$.

设某个在 $V_1$ 坐标系的坐标为 $x_1$, 对应的 $V_2$ 坐标系内的坐标为 $x_2$, 则 $B_1x_1 = B_2x_2$ = 自然基底下的坐标.

由此可得 $Cx_2 = x_1$ 或者 $x_2 = C^{-_1}x_1$, 可以理解为 $x_1$ 到 $x_2$ 需要左乘 $B_1$ 到 $B_2$ 的过渡矩阵的逆矩阵.

设 $V_1$ 坐标系内的某个变换为 $A_1$, 对应的 $V_2$ 坐标系内的变换为 $A_2$, 则 $B_1A_1x_1 = B_2A_2x_2$. 可得:

$$CA_2 = A_1C$$

解释: 我们可以通过坐标左乘对应基底过渡矩阵的逆矩阵, 将其变换为另一个坐标系的坐标, 然后计算变换后, 将其左乘对应的基底过渡矩阵来转为开始的坐标系的坐标.


### 以对象自身做变换

很多应用会设置一个锚点, 然后围绕它和对象建立的坐标系来进行变换.

设原始坐标系为 $V_1$, 基底 $B_1$, $V_1$ 坐标系内锚点 $O$, 对象坐标系为 $V_2$, 基底 $B_2$. 设 $B_1$ 到 $B_2$ 的过渡矩阵 $C$ 满足 $B_2 = B_1C$.

这个 $C$ 一般是一个平移矩阵, 等于从锚点 $O$ 平移到 $V_1$ 的原点.

我们对对象进行 $V_2$ 坐标系内的, 以 $O$ 为锚点的变换 $A_2$, 所以这个变换矩阵在 $V_1$ 对应的变换矩阵为 $A_1 = CA_2C^{-_1}$.

由于以元素自身坐标系做变换时, $V_2$ 坐标系内的坐标并不发生变化, 而实际发生变化的是基底. 由于最终自然基底下的坐标为 $B_2A_2x_2 = B_2'x_2$, 所以基底变为 $B_2' = B_2A_2$.

如此我们假设依次进行变换 $M_1$, $M_2$, 则基底 $B_2' = B_2M_1M_2$, 对应的 $V_1$ 坐标系的变换矩阵为 $M$, 最终的自然基底坐标为 $B_2'x_2 = B_1Mx_1$, 得到:

$$M_{final} = CM_1M_2C^{-_1}$$

解释: 以锚点 O 对对象进行变换, 相当于先应用 `Translate(-O)`, 然后按照顺序依次乘以每个变换矩阵, 最后应用 `Translate(O)`.


### Web 中的变换

CSS 的变换完全符合上述过程, 并且可以通过 `transform-origin` 设置锚点 O.

SVG 也符合上述过程, 但是注意其锚点默认为 SVG Viewport 坐标原点, 所以需要指定锚点时, 使用上述锚点平移处理即可.

Canvas 中的所有变换方法均用于变换基底, 所以也符合上述过程, 锚点的处理也和 SVG 相同.


