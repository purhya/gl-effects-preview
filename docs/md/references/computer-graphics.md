# <<计算机图形学>> 的阅读参考

<div>
	<img src="images/computer-graphic-with-opengl.jpg" style="width: 262px; height: 370px; display: inline-block;">
	<img src="images/interactive-computer-graphic.jpg" style="width: 262px; height: 370px; display: inline-block; margin-left: 20px">
</div>



### 来源

<<计算机图形学>> 是我的大学教科书, 毕业时扔了, 不过后来可能出于未好好读这本书的愧疚我又买了一本, 但是很长时间都没有阅读.

直到 2017 年, 遇到了一个关于 CSS 变换矩阵的问题, 读了大概 1/3 并且解决了问题, 之后没有啥动力又暂停了.

直到 2019 年, 需要解决一个从离散点生成多个区域的几何问题, 而且还打算之后深入学习 WebGL, 所以一口气读完了整本书, 当然也成功解决了这个问题.



### 计算机图形的开发难在何处

软件开发流程可以用 “输入 – 运算 – 输出” 来概括.

一般的软件开发流程, 输入和输出偏重于数字信息, 运算部分以处理业务逻辑为主, 由于一致在 CPU 端运行, 需要的算法也可以运用别人的模块化成果.

图形和图像开发的输入包含图像信息、几何信息等, 输出一般是图像信息, 这些信息一般是百万级别, 而实时绘制系统要求每一帧 (一般是 16 毫秒) 都处理这么多信息. 所以需要使用 GPU 来执行并行运算.

GPU 为了保证高效运行, 只负责处理基本图元比如点、线、三角形, 从输入转为基本图元是一个复杂的过程, 和具体的业务相关性很强, 也没有通用的模块化的方式. 一般只对其中具体的数学过程进行模块化, 或者做专用的例如模型结构的模块化.

对于持续的绘制, CPU 端管理绘制流程和 GPU 资源是一个很大的考验. 尤其对于实时绘制系统, 需要在帧绘制的间隙精确管理 GPU 资源, 这个过程还关系到最后的绘制效率. 不过此方面属于软件工程的范畴, 有较成熟的例子可供参考, 并且已积累的软件工程经验适用这个过程.

将具体的业务需求拆解为 CPU 端和 GPU 端紧密配合的两部分也具有一定的工程难度. 不过这个难度会随着经验的上升陡然下降.

编写 GPU 端基本图元的着色代码, 则是一个反直觉、高度依赖数学建模能力和经验的步骤, 没有可靠的模块化方式, 而且直接关系到最后的绘制效率. 可找到的着色代码资源一般都几乎无法阅读, 只有数学模型是通用的, 所以最佳的方式是培养理解模型所需的基础数学以及其对应的语言.

简单说来计算机图形的开发需要工程和数学的紧密配合.



### 这本书解决的以及未解决的问题

这本书是一本原理性书籍, 不能够让你马上进行开发, 但是它奠定了图形开发需要的从建模、几何图形到像素的基础内容.

但是这本书毕竟只是基础内容, 在实际的开发过程中会涉及到许多其他方面的知识:

1. 建立数学模型 – 主要来自于基础数学以及具体模型的积累, 没有通用的办法.
2. OpenGL 的整个绘制流程 – 建议阅读 <<OpenGL 编程指南>>, 以及查阅网上的一些优秀资料, 然后仍然需要自己梳理.
3. 持续绘制或者实时绘制的调度流程 – 我没有找到比较可靠的参考资料, 不过应该所有的这类系统都可以作为潜在的参考.
4. 网格划分和细分 – 目前我所了解的图形学最难的部分, 并且有一个专门的数学分类 - "计算几何" 对应. 不过一般的开发不会遇到, 我只在做脸部变换时碰到过一个此类问题. 在没有基础数学知识支持的情况下解决此类问题几乎不可能.
5. 图像处理、滤镜以及视觉特效和后处理 – 归属图像领域, 目前我对此知之甚少, 准备从 <<数字图像处理>> 这本书切入.



### 阅读准备

首先这本书需要你有一定的微积分基础, 不需要很多, 主要是能理解微积分的表示以及意义.

另外建议先阅读 <<线性代数>>, 至少要读完基础运算以及线性方程组和线性空间, 否则将会无法正确理解图形学中的几何变换等核心内容, 也无法在应用开发中灵活运用.

整个阅读过程大约花费了我 4 周时间, 如果不需要推导里面的公式, 尤其是难度较大的样条部分, 应该只用花费一半的时间.



### 章节内容以及对于开发的重要程度

请至少通读整本书, 这样会对于计算机图形学有一个完整的概念.

1. 了解即可.
2. 了解即可.
3. 输出图元 – 此章为基础内容, 其中的绘制算法已被 OpenGL 内置或者没必要实现, 了解即可.
4. 图元属性 – 此章也是基础内容, 其中的基础算法已被 OpenGL 内置或者没必要实现, 但是建议了解一下, 可以帮助理解 OpenGL 的栅格化过程.
5. 几何变换 – 至关重要的一章, 讲解比较基础, 实际的应用中会遇到非常多对于此章节内容的综合应用. 需要掌握线性代数的线性空间及其变换. 另外齐次坐标部分我认为 <<交互式计算机图形学 …>> 那本书讲解的更好.
6. 二维观察 – 重要, 其中的裁剪算法被 OpenGL 内置, 而矩阵部分较简单, 可以选择在需要的时候补充. 尽管如此, 仍然需要一些数学分析才能明白观察和投影矩阵会产生什么样的效果, 以及要产生指定的效果需要怎样的矩阵.
7. 三维观察 – 同上.
8. 三维对象的表示 – 重要, 其中的大多算法被 OpenGL 内置, 样条部分极其重要但是比较难, 请至少掌握三次曲线以及贝塞尔曲线的表达方式和生成流程. B 样条和有理样条难度很大, 可随缘.
9. 可见面判别算法 – 其中的大多算法被 OpenGL 内置, 建议熟悉这些算法以增进对于 OpenGL 可见面判别的理解.
10. 光照模型和面绘制算法 – 重要, 其中的算法在应用时需要自己实现, 可选择在需要时再仔细研究其中的所需部分.
12. 颜色模型和颜色应用 – 基础部分, 适当了解即可, 实际编程时可以从很多渠道学习这方面的知识.
13. 了解即可.
14. 了解即可.
15. 了解即可.



### 阅读 <<交互式计算机图形学>>

在 2020 年 1 月, 我又对照阅读了 <<交互式计算机图形学 – 基于 WebGL 的自顶向下方法>>. 这本书还有一个 OpenGL 版本.

相比之下 <<计算机图形学>> 的出发点是整个学科, 作者具有深厚的数学功底, 数学语言精准而贴切, 但会显得 “不实用” 的东西比较多.

而这本书更加贴近开发者, 章节内容也据此引出, 显得更加 “实用”. 如果你读完了 <<计算机图形学>>, 你会发现这本书是一个非常好的补充. 如果希望速成, 这本书应当比 <<计算机图形学>> 更加合适.

但是需要注意的是, 这本书有着比较大的缺陷, 里面的数学部分没有 <<计算机图形学>> 准确和完整, 一些地方显得跳跃性比较大. 如果对数学部分的内容有比较高的需求的话, 请对照 <<计算机图形学>> 阅读.

另外此书的第 11 章 – 曲线和曲面, 从描述、公式到配图都有大量的错误以及不妥之处, 章节和内容划分也不如 <<计算机图形学>>. 建议直接阅读 <<计算机图形学>> 的第 8 章代替或者做对照阅读.
