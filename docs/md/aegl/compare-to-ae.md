# AEGL 和 AE 的渲染架构区别

为什么 AE 渲染即使是 360P 的视频, 速度仍然慢得惊人, 而同样的电脑在 1080P 下运行看起来复杂的多 3A 游戏, 却非常流畅?

以下内容来自于个人对于 AE 渲染原理和 AEGL 的基本分析, 可以大致回答这个问题.


### AE 的渲染架构

AE 的视频制作基于层, 混合层可以嵌套另一个层, 此外还有调整图层可以作用于之下的所有图层. 从概念上看, 我们可以理解为上一个层渲染结果作为下一个层的输入, 这样串起来会形成一个线性流程. 这个过程当然可以在许多地方是可以优化的, 不过总体上符合.

这样带来的好处是层与层之间不会产生纠缠, 每个层的渲染可以独立处理, 方便了功能的模块化, 也方面了插件的编写. 缺点就是效率, 因为它会反复读写帧缓冲.

另一个问题来自于 AE 的算法, 从资源占用来看, AE 的渲染算法集中在 CPU 端, 这样可以更方便地使用、编写、以及扩展渲染算法模块.

渲染算法应当也可以使用 GPU 渲染, 但是以 CPU 为主的渲染模式下, 执行 GPU 渲染会牵扯到 CPU 和 GPU 的数据双向传输, 并额外增加时间消耗和复杂度, 所以 GPU 实际很少会被用于渲染.

此外 AE 使用的默认缩放算法为 bicubic (双三次). 这会带来更低的效率, 但是会让图片在缩放时有更强的对比度, 看起来更加 "透亮".

此外, 还有一些比较极端的案例, 例如运动模糊. 通用的运动模糊需要对于每一帧都将时刻略微偏移然后渲染多帧再合成为一帧. 这可能会造成渲染时间倍增.


### AEGL 的渲染架构

对比之下, 基于 GPU 的渲染架构截然不同 - CPU 一般只负责准备输入数据以及处理渲染调度, 不负责运算量极大的像素渲染, 几乎所有的像素渲染均在 GPU 端完成. 并且像素数据一直存储在 GPU 端. 这意味着所有的特效算法都应当通过着色代码来实现, 但是着色代码的编写复杂.

另一方面 CPU 端可以对绘制模型和流程进行优化, 以努力减少绘制的流程. 例如将多个图层以及调整图层的变换通过矩阵合成为一个变换, 从而通过一次绘制来完成. 这个过程对于绘制效率提升巨大, 但是它也意味着不同层的属性之间会产生关联, 因此会增加绘制调度的复杂度.

OpenGL 使用的默认缩放算法为 linear, 其效率很高. 但是质量上相比 bicubic 会略有不足. 不过可以自己实现 bicubic, 缺点是会带来效率的损失.

另外运动模糊这类复杂的渲染也可以使用像素的采样位置相对于时间的微分来决定模糊的半径和方向的方式来近似实现, 其算法较复杂, 但是对于效率会有巨大的提升.


### 总结

综合来说, 其一是运行效率, 其二是结构简单和易扩展, AE 选了后者.