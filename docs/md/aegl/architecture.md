# AEGL 架构


### 插件部分

负责从一个 AE 工程导出其基本信息, 层结构, 效果参数以及资源文件.

导出资源文件时会自动将图片和视频进行压缩以让其便于做线上渲染.

图片会被转为 jpg, 对于无损原 png 图片的压缩比大约为 1/8; 视频会被转为 webm, 并且维持最大 960p. 相比无损原 mov 视频的压缩比大约为 1/50.

此外, 插件可以支持多套素材的导出, 例如渲染最终视频的高分辨率素材, 以及便于实时预览的低质量素材.



### 数学部分

托管于 `/libs/math`.

 - Matrix: 矩阵库, 实现了基本的矩阵运算. 数据格式基于行优先.
 - Transform: 变换库, 在矩阵的基础上封装的 4x4 的变换矩阵的运算.



### WebGL 基础库

托管于 `/src/libs/webgl`.

 - `simple-Webgl`: 核心类, 对应着一个 WebGL 的绘图上下文, 可以配置全局的环境的信息.
 - `vertices`: 顶点数据类, 一个顶点数据可以被多个 `ToDraw` 对象共享.
 - `sampler`: 纹理采样器类, 一个采样器可以被多个 `ToDraw` 对象共享.
	- `TextureSampler`: 普通的 RGBA 采样器, 对应着一个像素资源.
	- `FloatSampler`: 浮点数采样器, 对应着一个二维的浮点数资源.
	- `TextureFrameSampler`: 纹理缓存采样器, 用于将像素绘制于其中然后再做后处理.
 - `todraw`: 对应着一个绘制对象, 一个 `SimpleWebGL` 可以创建多个 `ToDraw` 对象对应着多步的绘制.
	- `vertices`: 顶点数据.
	- `samplers`: 纹理数据, `{name: sampler[]}` 格式.

WebGL 基础库封装了复杂的顶点和纹理数据管理, 只需要创建对应的 `Vertices` 和 `Sampler` 对象, 然后让 `ToDraw` 对象使用它们即可.

当创建 `ToDraw` 对象以及其关联的顶点和纹理数据之后, 这些数据会被立刻同步到 GPU, 在 `ToDraw` 对象释放前都不会被释放.  所以 `ToDraw` 不再使用时一定要将其释放.

如果整个的绘制流程很长, 你可以选择一次初始化所有的 `ToDraw` 对象, 这样资源全部上传之后, 整个渲染过程会非常流畅, 但是 GPU 内存消耗会较大, 另外也会花费比较长的时间从网络加载这些资源源数据; 也可以选择慢慢初始化 `ToDraw` 对象, 例如提前初始化接下来 3 秒的绘制对象. 不过缺点是渲染过程中因为 CPU 忙碌或者资源未能加载完成会产生丢帧.



### AEGL 库

托管于 `/src/aegl`.

##### 类型部分:

 `aegl-types`: 定义了 JSON 数据接口.
 `aegl-default-values`: 定义了 JSON 数据结构中的默认值.

##### project 部分:

 - `json-loader`: 用于加载 JSON 工程.
 - `porject`: 一个渲染工程, 用于保持数据, 以及作为桥梁沟通其他类.
 - `resource-loader`: 用于加载工程的资源文件.
 - `timeline`: 用于根据当前时间获得应当被激活的层, 以及根据一个预加载设置获得需要预加载的层.
 - `editor-sample`: 一个编辑类的示例, 用于演示编辑层数据. 编辑功能和具体业务直接相关, 所以将在之后有需要再开发.

`timeline/AEGLTimeline` 类在生成某个时刻的层数据时, 会生成一个时间段, 在该时间段内会都会获得这个结果, 因此不用每一帧期间都查询所有的层数据. 借此降低了查询层时的 CPU 平均使用率.

此外 `AEGLTimeline` 可以设置预加载策略, 以全部加载所有资源来保证预览流畅, 或者仅预加载一小段时间以保证低内存和显存使用.


##### property 部分:

 - `effect-transform`: 用于计算变换特效的对应矩阵.
 - `effect`: 用于对特效进行归类.
 - `keyframe`: 用于计算关键帧在当前时刻的值, 支持线性和贝塞尔插值.
 - `property`: 用于计算当前时刻的属性值, 此外还有一个缓存类, 用于缓存不包含关键帧的静态属性.
 - `tile`: 用于计算 Motion Tile 的变换矩阵.
 - `transform`: 用于计算层自身的变换矩阵.

`keyframe` 和 `property` 均有缓存控制, 目的也是为了缓存每一帧期间都要查询的层数据. 以降低 CPU 的平均使用率.


##### renderer 部分:

 - `effect/**`: 包含了用于渲染后期特效的类.
 - `layer/**`: 包含了用于渲染层的类.
 - `layer-effect-manager/**`: 用于管理当前时刻激活的层以及效果类.
 - `render-nodes-compiler`: 用于将当前时刻的层数据编译为一个渲染树.
 - `render-tree`: 当前时刻的层编译而成的渲染树, 遍历其节点以迭代变换矩阵和进行绘制.
 - `renderer`: 用于进行渲染的时间调度, 在需要时更新渲染树, 以及每一帧绘制渲染树.
 - `transform-stat`: 用于从渲染树结构统计每一个层的可能的变换状态, 并且决定相应层的最佳的采样方式.

此部分为整个绘制的核心, 也是最复杂的部分.



### 简化的流程归纳:

##### 初始化

 1. 加载项目 json 数据, 选择一个分辨率 (一般是 1080p, 事实上也可以支持任何分辨率下的渲染).
 2. 初始化一个工程类, 以及所有相关的类.


##### 构建渲染树

 1. 查询预加载策略下会加载的所有层, 预创建这些层.
 2. 查询当前需要渲染的所有层, 然后构建渲染树.
 3. 通过递归分析渲染树中的变换属性设置, 推测并更新层的变换方式, 以及最佳的采样方式和缩放比.


##### 渲染

 1. 递归分析渲染树的节点的变换属性, 并且做累积.
 2. 更新层的时间以及变换属性.
 3. 递归绘制渲染树节点.
